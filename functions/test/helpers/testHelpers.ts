import * as admin from 'firebase-admin';
import * as functionsTest from 'firebase-functions-test';
import { expect } from 'chai';

// Initialize Firebase Functions Test
const testEnv = functionsTest();

// Initialize Firebase Admin (if not already initialized)
if (!admin.apps.length) {
  admin.initializeApp({
    projectId: 'formgenai-4545-test',
  });
}

export { testEnv, admin, expect };

/**
 * Test data helpers
 */
export const testHelpers = {
  /**
   * Generate a unique test ID
   */
  generateTestId(prefix: string = 'test'): string {
    return `${prefix}_${Date.now()}_${Math.random().toString(36).substring(7)}`;
  },

  /**
   * Clean up test data from Firestore
   */
  async cleanupTestData(collectionPath: string, docId: string): Promise<void> {
    try {
      await admin.firestore().collection(collectionPath).doc(docId).delete();
      console.log(`Cleaned up ${collectionPath}/${docId}`);
    } catch (error) {
      console.warn(`Failed to cleanup ${collectionPath}/${docId}:`, error);
    }
  },

  /**
   * Clean up multiple documents
   */
  async cleanupMultiple(items: Array<{ collection: string; id: string }>): Promise<void> {
    await Promise.all(
      items.map(item => this.cleanupTestData(item.collection, item.id))
    );
  },

  /**
   * Create a mock template for testing
   */
  createMockTemplate(overrides: Partial<any> = {}): any {
    return {
      id: this.generateTestId('template'),
      name: 'Test Template',
      originalFileName: 'test_template.docx',
      fileUrl: 'https://storage.googleapis.com/test/template.docx',
      fileType: 'docx' as const,
      extractedFields: [],
      status: 'parsed' as const,
      createdAt: new Date(),
      updatedAt: new Date(),
      etag: this.generateTestId('etag'),
      currentVersion: 0,
      ...overrides,
    };
  },

  /**
   * Create mock placeholder fields
   */
  createMockPlaceholders(count: number = 3): any[] {
    return Array.from({ length: count }, (_, i) => ({
      field_key: `field_${i + 1}`,
      label: `Field ${i + 1}`,
      type: 'string',
      required: i === 0, // First field is required
      description: `Test field ${i + 1}`,
      locations: [
        {
          page: 1,
          section: `section_${i + 1}`,
        },
      ],
      confidence: 0.95,
    }));
  },

  /**
   * Create a mock service
   */
  createMockService(templateIds: string[], overrides: Partial<any> = {}): any {
    return {
      id: this.generateTestId('service'),
      name: 'Test Service',
      description: 'Test service description',
      templateIds,
      masterFormJson: this.createMockPlaceholders(5),
      status: 'active' as const,
      createdAt: new Date(),
      updatedAt: new Date(),
      ...overrides,
    };
  },

  /**
   * Create a mock customer override
   */
  createMockCustomerOverride(templateIds: string[], overrides: Partial<any> = {}): any {
    return {
      id: this.generateTestId('override'),
      customerId: this.generateTestId('customer'),
      templateIds,
      modifications: [
        {
          field_key: 'custom_field_1',
          label: 'Custom Field 1',
          type: 'string',
          required: true,
          description: 'Custom field description',
          locations: [{ section: 'custom_section' }],
          confidence: 1.0,
        },
      ],
      customSections: [
        {
          content: 'This is a custom clause generated by AI.',
          insertAfter: 'field_1',
          placeholders: ['custom_field_1'],
        },
      ],
      status: 'draft' as const,
      createdAt: new Date(),
      updatedAt: new Date(),
      createdBy: 'test_user',
      ...overrides,
    };
  },

  /**
   * Create a mock intake
   */
  createMockIntake(serviceId: string, overrides: Partial<any> = {}): any {
    return {
      id: this.generateTestId('intake'),
      serviceId,
      serviceName: 'Test Service',
      linkToken: this.generateTestId('token'),
      clientData: {
        field_1: 'Test Value 1',
        field_2: 'Test Value 2',
        field_3: 'Test Value 3',
      },
      status: 'submitted' as const,
      createdAt: new Date(),
      updatedAt: new Date(),
      clientEmail: 'test@example.com',
      clientName: 'Test Client',
      ...overrides,
    };
  },

  /**
   * Create a mock version snapshot
   */
  createMockVersionSnapshot(templateVersions: Record<string, number>, overrideId?: string): any {
    return {
      templateVersions,
      effectiveSchema: this.createMockPlaceholders(5),
      overrideId,
      frozenAt: new Date(),
      frozenBy: 'test_user',
    };
  },

  /**
   * Wait for async operations
   */
  async wait(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  },

  /**
   * Retry an operation with exponential backoff
   */
  async retry<T>(
    operation: () => Promise<T>,
    maxAttempts: number = 3,
    delayMs: number = 1000
  ): Promise<T> {
    let lastError: any;
    
    for (let attempt = 1; attempt <= maxAttempts; attempt++) {
      try {
        return await operation();
      } catch (error) {
        lastError = error;
        if (attempt < maxAttempts) {
          await this.wait(delayMs * attempt); // Exponential backoff
          console.log(`Retry attempt ${attempt + 1}/${maxAttempts}...`);
        }
      }
    }
    
    throw lastError;
  },

  /**
   * Assert that a Firestore document exists
   */
  async assertDocumentExists(collectionPath: string, docId: string): Promise<void> {
    const doc = await admin.firestore().collection(collectionPath).doc(docId).get();
    expect(doc.exists).to.be.true;
  },

  /**
   * Assert that a Firestore document does not exist
   */
  async assertDocumentNotExists(collectionPath: string, docId: string): Promise<void> {
    const doc = await admin.firestore().collection(collectionPath).doc(docId).get();
    expect(doc.exists).to.be.false;
  },

  /**
   * Get a Firestore document
   */
  async getDocument(collectionPath: string, docId: string): Promise<any> {
    const doc = await admin.firestore().collection(collectionPath).doc(docId).get();
    return doc.data();
  },

  /**
   * Create a Firestore document for testing
   */
  async createDocument(collectionPath: string, docId: string, data: any): Promise<void> {
    await admin.firestore().collection(collectionPath).doc(docId).set(data);
  },
};

/**
 * Mock OpenAI responses for testing
 */
export const mockOpenAI = {
  /**
   * Mock detectPlaceholders response
   */
  detectPlaceholdersResponse: {
    placeholders: testHelpers.createMockPlaceholders(5),
  },

  /**
   * Mock suggestPlaceholder response
   */
  suggestPlaceholderResponse: {
    field_key: 'suggested_field',
    label: 'Suggested Field',
    type: 'string',
    required: false,
    description: 'AI-suggested field',
    locations: [{ section: 'suggested_section' }],
    confidence: 0.85,
  },

  /**
   * Mock generateCustomClause response
   */
  generateCustomClauseResponse: {
    content: 'This is a custom clause generated by AI based on the user requirements.',
    placeholders: ['custom_field_1', 'custom_field_2'],
    confidence: 0.90,
  },
};

/**
 * Cleanup function to be called after tests
 */
export async function cleanup() {
  // Clean up any remaining test data
  console.log('Test cleanup complete');
}
