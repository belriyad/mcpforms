import { test, expect } from '@playwright/test';

const BASE_URL = 'http://localhost:3000';

// Test data for comprehensive form filling
const CLIENT_TEST_DATA = {
  personal: {
    firstName: 'John',
    lastName: 'Smith', 
    middleName: 'Michael',
    fullName: 'John Michael Smith',
    email: 'john.smith@example.com',
    phone: '555-123-4567',
    mobile: '555-987-6543',
    dateOfBirth: '1980-01-15',
    age: '43',
    ssn: '123-45-6789',
    driversLicense: 'D1234567',
    citizenship: 'US Citizen',
    maritalStatus: 'Married'
  },
  address: {
    street: '123 Main Street',
    address1: '123 Main Street',
    address2: 'Unit 4B',
    city: 'Anytown',
    state: 'CA',
    zipCode: '90210',
    country: 'United States',
    county: 'Los Angeles'
  },
  business: {
    company: 'Acme Corporation',
    companyName: 'Acme Corporation',
    organization: 'Acme Corporation',
    title: 'Chief Executive Officer',
    position: 'CEO',
    jobTitle: 'CEO',
    businessPhone: '555-456-7890',
    workEmail: 'john@acmecorp.com',
    industry: 'Technology',
    employeeId: 'EMP001'
  },
  financial: {
    annualIncome: '150000',
    salary: '150000',
    bankName: 'First National Bank',
    accountNumber: '1234567890',
    routingNumber: '123456789',
    creditScore: '750'
  },
  legal: {
    attorneyName: 'Jane Legal',
    caseNumber: 'CASE2024001',
    courtName: 'Superior Court',
    previousNames: 'None',
    criminalHistory: 'None'
  },
  emergency: {
    emergencyContact: 'Jane Smith',
    emergencyPhone: '555-111-2222',
    relationship: 'Spouse',
    emergencyEmail: 'jane.smith@example.com'
  },
  medical: {
    physician: 'Dr. Smith',
    medicalConditions: 'None',
    medications: 'None',
    allergies: 'None',
    insuranceProvider: 'Blue Cross',
    policyNumber: 'BC123456'
  },
  other: {
    comments: 'This is a comprehensive test of the intake form system with all possible field types and values.',
    notes: 'Generated by automated Playwright test.',
    additionalInfo: 'Please process this test submission for document generation verification.',
    specialInstructions: 'This is a test - please generate documents for verification.',
    signature: 'John Michael Smith',
    signatureDate: '2024-12-29'
  }
};

// Known intake URLs for testing (replace with actual URLs from your system)
const TEST_INTAKE_URLS = [
  // Add real intake URLs here when available
  'http://localhost:3000/intake/test-token-123',
  'http://localhost:3000/intake/demo-form-456'
];

test.describe('MCPForms - Comprehensive Form Filling and Submission', () => {
  
  test('Fill and submit intake form with comprehensive data', async ({ page }) => {
    console.log('üìù Starting comprehensive form filling test...');
    
    // Monitor form submission
    let submissionSuccess = false;
    let submissionResponse: any = null;
    
    page.on('response', async (response) => {
      if (response.url().includes('/submit') || response.url().includes('/intake/')) {
        try {
          if (response.status() === 200) {
            submissionResponse = await response.json();
            submissionSuccess = true;
            console.log('‚úÖ Form submission response received');
          }
        } catch (error) {
          // Ignore JSON parsing errors
        }
      }
    });
    
    // Test with the first available intake URL
    // In a real test, you'd get this from generating a new intake link
    const testUrl = TEST_INTAKE_URLS[0];
    
    console.log('üîó Testing intake URL:', testUrl);
    await page.goto(testUrl);
    
    // Wait for form to load
    await page.waitForLoadState('networkidle');
    
    // Check if the page loaded successfully
    const pageTitle = await page.title();
    console.log('üìÑ Page title:', pageTitle);
    
    // Fill form comprehensively
    await fillFormComprehensively(page);
    
    // Submit form
    await submitForm(page);
    
    // Verify submission
    await verifySubmission(page);
    
    console.log('‚úÖ Comprehensive form filling test completed');
  });
  
  test('Test form auto-save functionality', async ({ page }) => {
    console.log('üíæ Testing form auto-save functionality...');
    
    const testUrl = TEST_INTAKE_URLS[0];
    await page.goto(testUrl);
    await page.waitForLoadState('networkidle');
    
    // Fill some fields
    await fillBasicFormFields(page);
    
    // Wait for auto-save (if implemented)
    await page.waitForTimeout(3000);
    
    // Refresh page to test if data persists
    await page.reload();
    await page.waitForLoadState('networkidle');
    
    // Check if form data was restored
    const firstNameField = page.locator('input[name*="firstName"], input[name*="first"]').first();
    if (await firstNameField.isVisible()) {
      const savedValue = await firstNameField.inputValue();
      if (savedValue === CLIENT_TEST_DATA.personal.firstName) {
        console.log('‚úÖ Auto-save functionality working');
      } else {
        console.log('‚ö†Ô∏è Auto-save not detected or not working');
      }
    }
  });
  
  test('Test form validation and error handling', async ({ page }) => {
    console.log('üîç Testing form validation...');
    
    const testUrl = TEST_INTAKE_URLS[0];
    await page.goto(testUrl);
    await page.waitForLoadState('networkidle');
    
    // Try to submit empty form
    const submitButton = page.locator('button[type="submit"], button:has-text("Submit")').first();
    if (await submitButton.isVisible()) {
      await submitButton.click();
      
      // Check for validation errors
      const errorMessages = page.locator('.error, .invalid, [class*="error"], [class*="invalid"]');
      const errorCount = await errorMessages.count();
      
      console.log(`üîç Found ${errorCount} validation errors (expected for empty form)`);
      
      if (errorCount > 0) {
        console.log('‚úÖ Form validation is working');
      } else {
        console.log('‚ö†Ô∏è No validation errors found - validation may not be implemented');
      }
    }
  });
});

async function fillFormComprehensively(page: any) {
  console.log('üìù Starting comprehensive form filling...');
  
  // Create a comprehensive field mapping
  const fieldMappings = [
    // Personal Information
    { selectors: ['input[name*="firstName"]', 'input[name*="first_name"]', 'input[name*="first"]', 'input[placeholder*="First"]'], value: CLIENT_TEST_DATA.personal.firstName },
    { selectors: ['input[name*="lastName"]', 'input[name*="last_name"]', 'input[name*="last"]', 'input[placeholder*="Last"]'], value: CLIENT_TEST_DATA.personal.lastName },
    { selectors: ['input[name*="middleName"]', 'input[name*="middle"]'], value: CLIENT_TEST_DATA.personal.middleName },
    { selectors: ['input[name*="fullName"]', 'input[name*="name"]', 'input[placeholder*="Full Name"]'], value: CLIENT_TEST_DATA.personal.fullName },
    { selectors: ['input[name*="email"]', 'input[type="email"]'], value: CLIENT_TEST_DATA.personal.email },
    { selectors: ['input[name*="phone"]', 'input[type="tel"]', 'input[name*="telephone"]'], value: CLIENT_TEST_DATA.personal.phone },
    { selectors: ['input[name*="mobile"]', 'input[name*="cell"]'], value: CLIENT_TEST_DATA.personal.mobile },
    { selectors: ['input[name*="dateOfBirth"]', 'input[name*="dob"]', 'input[name*="birthDate"]', 'input[type="date"]'], value: CLIENT_TEST_DATA.personal.dateOfBirth },
    { selectors: ['input[name*="age"]'], value: CLIENT_TEST_DATA.personal.age },
    { selectors: ['input[name*="ssn"]', 'input[name*="social"]', 'input[name*="socialSecurity"]'], value: CLIENT_TEST_DATA.personal.ssn },
    
    // Address Information
    { selectors: ['input[name*="address"]', 'input[name*="street"]', 'input[name*="address1"]'], value: CLIENT_TEST_DATA.address.street },
    { selectors: ['input[name*="address2"]', 'input[name*="apt"]', 'input[name*="unit"]'], value: CLIENT_TEST_DATA.address.address2 },
    { selectors: ['input[name*="city"]'], value: CLIENT_TEST_DATA.address.city },
    { selectors: ['input[name*="state"]', 'select[name*="state"]'], value: CLIENT_TEST_DATA.address.state },
    { selectors: ['input[name*="zip"]', 'input[name*="postal"]', 'input[name*="zipCode"]'], value: CLIENT_TEST_DATA.address.zipCode },
    { selectors: ['input[name*="country"]'], value: CLIENT_TEST_DATA.address.country },
    { selectors: ['input[name*="county"]'], value: CLIENT_TEST_DATA.address.county },
    
    // Business Information
    { selectors: ['input[name*="company"]', 'input[name*="organization"]', 'input[name*="employer"]'], value: CLIENT_TEST_DATA.business.company },
    { selectors: ['input[name*="title"]', 'input[name*="position"]', 'input[name*="jobTitle"]'], value: CLIENT_TEST_DATA.business.title },
    { selectors: ['input[name*="businessPhone"]', 'input[name*="workPhone"]'], value: CLIENT_TEST_DATA.business.businessPhone },
    { selectors: ['input[name*="workEmail"]', 'input[name*="businessEmail"]'], value: CLIENT_TEST_DATA.business.workEmail },
    
    // Financial Information
    { selectors: ['input[name*="income"]', 'input[name*="salary"]'], value: CLIENT_TEST_DATA.financial.annualIncome },
    { selectors: ['input[name*="bankName"]', 'input[name*="bank"]'], value: CLIENT_TEST_DATA.financial.bankName },
    { selectors: ['input[name*="account"]', 'input[name*="accountNumber"]'], value: CLIENT_TEST_DATA.financial.accountNumber },
    
    // Emergency Contact
    { selectors: ['input[name*="emergencyContact"]', 'input[name*="emergency"]'], value: CLIENT_TEST_DATA.emergency.emergencyContact },
    { selectors: ['input[name*="emergencyPhone"]'], value: CLIENT_TEST_DATA.emergency.emergencyPhone },
    { selectors: ['input[name*="relationship"]'], value: CLIENT_TEST_DATA.emergency.relationship },
    
    // Signature and Date
    { selectors: ['input[name*="signature"]'], value: CLIENT_TEST_DATA.other.signature },
    { selectors: ['input[name*="signatureDate"]'], value: CLIENT_TEST_DATA.other.signatureDate }
  ];
  
  let fieldsFound = 0;
  let fieldsSuccessfullyFilled = 0;
  
  // Fill input fields
  for (const mapping of fieldMappings) {
    for (const selector of mapping.selectors) {
      const elements = page.locator(selector);
      const count = await elements.count();
      
      if (count > 0) {
        fieldsFound++;
        try {
          const element = elements.first();
          await element.fill(mapping.value);
          fieldsSuccessfullyFilled++;
          console.log(`‚úÖ Filled: ${selector} = ${mapping.value}`);
          break; // Move to next mapping once we fill one field
        } catch (error) {
          console.log(`‚ö†Ô∏è Failed to fill ${selector}:`, error instanceof Error ? error.message : String(error));
        }
      }
    }
  }
  
  // Handle select/dropdown fields
  const selectFields = page.locator('select');
  const selectCount = await selectFields.count();
  
  for (let i = 0; i < selectCount; i++) {
    try {
      const select = selectFields.nth(i);
      const options = select.locator('option');
      const optionCount = await options.count();
      
      if (optionCount > 1) {
        // Try to select based on field name or select a reasonable default
        const selectName = await select.getAttribute('name') || '';
        
        if (selectName.toLowerCase().includes('state')) {
          await select.selectOption({ value: 'CA' });
        } else if (selectName.toLowerCase().includes('country')) {
          await select.selectOption({ value: 'US' });
        } else {
          // Select second option (skip first which is usually empty)
          await select.selectOption({ index: 1 });
        }
        
        console.log(`‚úÖ Selected option in dropdown: ${selectName}`);
        fieldsSuccessfullyFilled++;
      }
    } catch (error) {
      console.log(`‚ö†Ô∏è Failed to handle select field:`, error instanceof Error ? error.message : String(error));
    }
  }
  
  // Handle textarea fields
  const textareas = page.locator('textarea');
  const textareaCount = await textareas.count();
  
  for (let i = 0; i < textareaCount; i++) {
    try {
      const textarea = textareas.nth(i);
      const name = await textarea.getAttribute('name') || '';
      
      let textValue = CLIENT_TEST_DATA.other.comments;
      
      // Customize content based on field name
      if (name.toLowerCase().includes('comment')) textValue = CLIENT_TEST_DATA.other.comments;
      else if (name.toLowerCase().includes('note')) textValue = CLIENT_TEST_DATA.other.notes;
      else if (name.toLowerCase().includes('additional')) textValue = CLIENT_TEST_DATA.other.additionalInfo;
      else if (name.toLowerCase().includes('instruction')) textValue = CLIENT_TEST_DATA.other.specialInstructions;
      
      await textarea.fill(textValue);
      console.log(`‚úÖ Filled textarea: ${name}`);
      fieldsSuccessfullyFilled++;
    } catch (error) {
      console.log(`‚ö†Ô∏è Failed to fill textarea:`, error instanceof Error ? error.message : String(error));
    }
  }
  
  // Handle checkboxes and radio buttons
  const checkboxes = page.locator('input[type="checkbox"]');
  const checkboxCount = await checkboxes.count();
  
  for (let i = 0; i < checkboxCount; i++) {
    try {
      const checkbox = checkboxes.nth(i);
      if (!await checkbox.isChecked()) {
        await checkbox.check();
        console.log(`‚úÖ Checked checkbox ${i + 1}`);
        fieldsSuccessfullyFilled++;
      }
    } catch (error) {
      console.log(`‚ö†Ô∏è Failed to check checkbox:`, error instanceof Error ? error.message : String(error));
    }
  }
  
  console.log(`üìä Form filling summary: ${fieldsSuccessfullyFilled} fields filled successfully out of ${fieldsFound} fields found`);
}

async function fillBasicFormFields(page: any) {
  const basicFields = [
    { selectors: ['input[name*="firstName"]', 'input[name*="first"]'], value: CLIENT_TEST_DATA.personal.firstName },
    { selectors: ['input[name*="lastName"]', 'input[name*="last"]'], value: CLIENT_TEST_DATA.personal.lastName },
    { selectors: ['input[name*="email"]', 'input[type="email"]'], value: CLIENT_TEST_DATA.personal.email }
  ];
  
  for (const field of basicFields) {
    for (const selector of field.selectors) {
      const element = page.locator(selector).first();
      if (await element.isVisible({ timeout: 1000 })) {
        await element.fill(field.value);
        console.log(`üìù Filled basic field: ${selector}`);
        break;
      }
    }
  }
}

async function submitForm(page: any) {
  console.log('üì§ Attempting to submit form...');
  
  // Find and click submit button
  const submitSelectors = [
    'button[type="submit"]',
    'button:has-text("Submit")',
    'input[type="submit"]',
    'button:has-text("Send")',
    'button:has-text("Complete")',
    '.submit-button',
    '#submit'
  ];
  
  let submitted = false;
  
  for (const selector of submitSelectors) {
    const element = page.locator(selector);
    if (await element.isVisible({ timeout: 2000 })) {
      try {
        await element.click();
        console.log(`‚úÖ Clicked submit button: ${selector}`);
        submitted = true;
        break;
      } catch (error) {
        console.log(`‚ö†Ô∏è Failed to click ${selector}:`, error instanceof Error ? error.message : String(error));
      }
    }
  }
  
  if (!submitted) {
    console.log('‚ùå No submit button found or clicked');
  }
  
  // Wait for submission to process
  await page.waitForTimeout(3000);
}

async function verifySubmission(page: any) {
  console.log('üîç Verifying form submission...');
  
  // Look for success indicators
  const successSelectors = [
    'text=submitted successfully',
    'text=Thank you',
    'text=Form submitted',
    'text=Submission received',
    'text=Success',
    '.success-message',
    '.confirmation',
    'text=We have received your information'
  ];
  
  let successFound = false;
  
  for (const selector of successSelectors) {
    const element = page.locator(selector);
    if (await element.isVisible({ timeout: 5000 })) {
      console.log(`‚úÖ Success message found: ${selector}`);
      successFound = true;
      break;
    }
  }
  
  if (!successFound) {
    console.log('‚ö†Ô∏è No clear success message found');
    
    // Check for any error messages
    const errorSelectors = [
      'text=error',
      'text=failed',
      '.error-message',
      '.alert-danger',
      '[class*="error"]'
    ];
    
    for (const selector of errorSelectors) {
      const element = page.locator(selector);
      if (await element.isVisible({ timeout: 2000 })) {
        const errorText = await element.textContent();
        console.log(`‚ùå Error message found: ${errorText}`);
        break;
      }
    }
    
    // Take screenshot for debugging
    await page.screenshot({ 
      path: `test-results/form-submission-${Date.now()}.png`,
      fullPage: true 
    });
  }
  
  return successFound;
}